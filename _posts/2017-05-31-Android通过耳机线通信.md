---
layout: post
title: Android 耳机通信
category: android
tags: [android]
---
# 需求分析
1. 调制，根据原数据生成对应的PCM数据。
2. 传输，播放PCM文件。
3. 接收，另一台手机录音获取PCM数据。
4. 解调，PCM数据还原。
# 耳机原理
## 耳机接口
* 我们的手机中原装的耳机一般是带有话筒的，这种耳机分为四段分别为左声道、右声道、地、MIC。具体耳机可能线的顺序不同，可能Mic与Gnd调换了，具体情况需要测过才知道。此项目中需要把耳机MIC另一端接在L（R）上，L（R）接在另一端的MIC上。
## 话筒和耳机的声音原理
* 其实话筒接收的是振动信号，以些振动信号产生变化的电流，通过耳机接口传到手机里面的处理电路，最后被采样，生成PCM数据。

## Android播放PCM数据
```java
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

import android.app.Activity;
import android.media.AudioFormat;
import android.media.AudioManager;
import android.media.AudioTrack;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

public class MainActivity extends Activity {
    private static final String TAG = "MainActivity";
    private Button playBtn;
    private AudioTrack player;
    private int audioBufSize;
    private byte[] audioData;
    
    String  filePath  = "/sdcard/testmusic.pcm";
    private byte[] abc;
    int offset;
    Player player1;
    
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        audioBufSize = AudioTrack.getMinBufferSize(44100, AudioFormat.CHANNEL_OUT_STEREO, AudioFormat.ENCODING_PCM_16BIT);
        
        player = new AudioTrack(AudioManager.STREAM_MUSIC, 44100,AudioFormat.CHANNEL_OUT_STEREO,AudioFormat.ENCODING_PCM_16BIT,audioBufSize,AudioTrack.MODE_STREAM);
 
        playBtn = (Button)findViewById(R.id.button1);
        
        playBtn.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				player.play();			
				player1=new Player();
				player1.start();
            }
        });
    }
 class Player extends Thread{
    	byte[] data1=new byte[audioBufSize*2];
    	File file=new File(filePath);
    	int off1=0;
    	FileInputStream fileInputStream;
		
    	@Override
    	public void run() {
    		// TODO Auto-generated method stub
    		super.run();	
    		while(true){
    			try {
    				fileInputStream=new FileInputStream(file);
    				fileInputStream.skip((long)off1);
        			fileInputStream.read(data1,0,audioBufSize*2);
        			off1 +=audioBufSize*2;    			
    			} catch (Exception e) {
    				// TODO: handle exception
    			}
                player.write(data1, offset, audioBufSize * 2);			 
			}
    	}
    }
}

```

## Android录音保存为PCM数据
```java
public void rec(){
    MediaRecorder recorder = new MediaRecorder();
    recorder.setAudioSource(MediaRecorder.AudioSource.MIC);
    recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
    recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);
    recorder.setOutputFile(PATH_NAME);
    recorder.prepare();
    recorder.start(); // 开始录音
    ...
    recorder.stop();
    recorder.reset(); // You can reuse the object by going back to setAudioSource() step
    recorder.release(); // Now the object cannot be reused
}
```
## PCM格式分析
1. 音频简介
 >经常见到这样的描述: 

 >44100HZ 16bit stereo: 每秒钟有 44100 次采样, 采样数据用 16 位(2字节)记录, 双声道(立体声);

 >22050HZ 8bit  mono: 每秒钟有 22050 次采样, 采样数据用 8 位(1字节)记录, 单声道;
 
 当然也可以有 16bit 的单声道或 8bit 的立体声, 等等。
 采样率是指：声音信号在“模→数”转换过程中单位时间内采样的次数。采样值是指每一次采样周期内声音模拟信号的积分值。
 对于单声道声音文件，采样数据为八位的短整数（short int 00H-FFH）；
 而对于双声道立体声声音文件，每次采样数据为一个16位的整数（int），高八位(左声道)和低八位(右声道)分别代表两个声道。
 人对频率的识别范围是 20HZ - 20000HZ, 如果每秒钟能对声音做 20000 个采样, 回放时就足可以满足人耳的需求. 所以 22050 的采样频率是常用的, 44100已是CD音质, 超过48000的采样对人耳已经没有意义。这和电影的每秒 24 帧图片的道理差不多。
 每个采样数据记录的是振幅, 采样精度取决于储存空间的大小:
 - 1字节(也就是8bit) 只能记录 256 个数, 也就是只能将振幅划分成 256 个等级;
 - 2字节(也就是16bit) 可以细到 65536 个数, 这已是 CD 标准了;
 - 4字节(也就是32bit) 能把振幅细分到 4294967296 个等级, 实在是没必要了.
 如果是双声道(stereo), 采样就是双份的, 文件也差不多要大一倍.
 
 这样我们就可以根据一个 wav 文件的大小、采样频率和采样大小估算出一个 wav 文件的播放长度。
 譬如 "Windows XP 启动.wav" 的文件长度是 424,644 字节, 它是 "22050HZ / 16bit / 立体声" 格式(这可以从其 "属性->摘要" 里看到),那么它的每秒的传输速率(位速, 也叫比特率、取样率)是 22050*16*2 = 705600(bit/s), 换算成字节单位就是 705600/8 = 88200(字节/秒), 播放时间：424644(总字节数) / 88200(每秒字节数) ≈ 4.8145578(秒)。但是这还不够精确, 包装标准的 PCM 格式的 WAVE 文件(*.wav)中至少带有 42 个字节的头信息, 在计算播放时间时应该将其去掉, 所以就有：(424644-42) / (22050*16*2/8) ≈ 4.8140816(秒). 这样就比较精确了.
 
 关于声音文件还有一个概念: "位速", 也有叫做比特率、取样率, 譬如上面文件的位速是 705.6kbps 或 705600bps, 其中的 b 是 bit, ps 是每秒的意思;
 压缩的音频文件常常用位速来表示, 譬如达到 CD 音质的 MP3 是: 128kbps / 44100HZ.
有四种模式来定义如何启动一个Activity. 它们可以同时和 Intent 标志一起使用来定义各种不同的启动模式. 
下面是四种基本的启动模式.

## 四种启动模式

* **standard** (默认)
* **singleTop**
* **singleTask**
* **singleInstance**

## 如何设置启动模式

在 `AndroidManifest.xml` 设置启动模式 launchMode

{% highlight xml %}
<activity 
    android:name=".TestActivity"
    android:launchMode="standard|singleInstance|singleTask|singleTop">
</activity>
{% endhighlight %}

### standard

默认启动模式. 每个发送的 Intent 都会创建一个新的 Activity, 并且将其放入任务栈栈顶, 而不管这个 Activity 是否已经存在. Activity 的启动三回调(*onCreate()->onStart()->onResume()*)都会执行. 也就是说**每次都创建一个新的实例**.

### singleTop

如果新 Activity 已经位于任务栈的栈顶, 那么此 Activity 不会被重新创建, 所以它的启动三回调就不会执行, 同时 Activity 的 `onNewIntent()` 方法会被回调. 如果 Activity 已经存在却不在栈顶, 那么作用和标准模式一样, 一个新的 Activity 会被创建并放到栈顶.

在这个模式下, 我们必须同时在 `onCreate()`
 和 `onNewIntent()` 两个方法中处理好传入的 Intent.

#### 应用场景

比如搜索功能. 当用户在搜索条中搜索完会跳转到 SearchActivity 查看搜索结果. 通常, 我们在结果页面的顶端也会放置一个同样的搜索条, 这样用户就不需要回退就可以进行相同的搜索.

如果是 standard 模式, 搜索十次就会在栈里创建了十个 SearchActivity 实例, 同时用户需要按十次回退键才能回到之前的页面. 这明显比较二.

如果是 singleTop 模式, 当在搜索结果界面时, SearchActivity 处在栈的顶端. 所以我们只需要发送 Intent 到已经存在的 SearchActivity 实例, 更新页面的结果就足够了, 不需要创建新的 Activity. 同时只需要按一次回退就能回到之前的页面.

### singleTask

如果栈中任意位置已经有一个 Activity 实例, 那么这个 Activity 就会被调到栈顶, 始终保持一个实例,  同时回调 `onNewIntent()` , 并且 singleTask 会清理在当前 Activity 上面的所有 Activity.

### singleInstance

这个模式和 singleTask 很接近, 只会有一个实例存在. 不同点是**持有这个 Activity 的 Task 不能再有其他 Activity 的实例了**. 

如果从这个 Activity 中启动另外一个不同的 Activity, 将会自动创建一个新的 Task 来存放新的 Activity. 

如果从一个已经存在许多 Activity 的 Task 中调用  singleInstance Activity. 这个新 Activity 同样会被放在一个新的 Task 中.

## 参考

* [https://inthecheesefactory.com/blog/understand-android-activity-launchmode/en](https://inthecheesefactory.com/blog/understand-android-activity-launchmode/en)


